{
  "language": "Solidity",
  "sources": {
    "contracts/RockPaperScissors.sol": {
      "content": "pragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract RockPaperScissors {\n    address player;\n    address opponent;\n    uint256 public entranceFee;\n    address public token;\n\n    mapping(address => Game[]) private games;\n    mapping(address => uint256) public rewards;\n\n    event RewardLog(address indexed, uint256 amount, string message);\n\n    event Log(\n        address indexed challenger,\n        address indexed opponent,\n        string message\n    );\n\n    enum Status {\n        Playing,\n        Challenger,\n        Opponent,\n        Tie\n    }\n\n    struct Game {\n        Status status;\n        uint8 move1;\n        uint8 move2;\n        address challenger;\n        address opponent;\n        uint256 jackpot;\n    }\n\n    constructor(uint256 _entranceFee, address _token) {\n        entranceFee = _entranceFee;\n        token = _token;\n    }\n\n    // Start a game by depositing the enrollment fee, choosing your opponent and specifying your move\n    // 0 = Rock\n    // 1 = Paper\n    // 2 = Scissors\n\n    function startGame(\n        uint256 _amount,\n        address _opponent,\n        uint8 _move\n    ) public {\n        require(_amount >= entranceFee, \"fee to low\");\n        (bool isChallenged, uint256 index) = isChallengedMethod(\n            msg.sender,\n            _opponent\n        );\n        require(\n            isChallenged == false,\n            \"Already challenged this player to a game\"\n        );\n        require(\n            _move == 0 || _move == 1 || _move == 2,\n            \"move hast to be 0=Rock, 1=Paper, 2=Scissors\"\n        );\n        IERC20(token).transferFrom(msg.sender, address(this), _amount);\n        games[msg.sender].push(\n            Game({\n                move1: _move,\n                move2: 5,\n                status: Status.Playing,\n                challenger: msg.sender,\n                opponent: _opponent,\n                jackpot: _amount\n            })\n        );\n        emit Log(msg.sender, _opponent, \"game created\");\n    }\n\n    // Soneone Challanged you to a game, play by depositing the enrollment fee, providing the Challengers address and specifying your move\n    // 0 = Rock\n    // 1 = Paper\n    // 2 = Scissors\n\n    function opponentMove(\n        uint256 _amount,\n        address _challenger,\n        uint8 _move\n    ) public {\n        require(_amount >= entranceFee, \"fee to low\");\n        (bool isChallenged, uint256 index) = isChallengedMethod(\n            _challenger,\n            msg.sender\n        );\n        require(isChallenged == true, \"Player did not challenge you to a game\");\n        require(\n            games[msg.sender][index].status == Status.Playing,\n            \"Game already over\"\n        );\n        require(\n            _move == 0 || _move == 1 || _move == 2,\n            \"move hast to be 0=Rock, 1=Paper, 2=Scissors\"\n        );\n        IERC20(token).transferFrom(msg.sender, address(this), _amount);\n\n        games[msg.sender][index].move2 = _move;\n        games[msg.sender][index].jackpot = _amount;\n\n        Status gameStatus = logic(games[msg.sender][index].move1, _move);\n\n        uint256 price = games[msg.sender][index].jackpot + _amount;\n\n        if (gameStatus == Status.Tie) {\n            rewards[_challenger] =\n                rewards[_challenger] +\n                games[_challenger][index].jackpot;\n            rewards[msg.sender] = rewards[msg.sender] + _amount;\n            emit Log(_challenger, msg.sender, \"Its a Tie\");\n        } else if (gameStatus == Status.Challenger) {\n            rewards[_challenger] = rewards[_challenger] + price;\n            emit Log(_challenger, msg.sender, \"Challenger Won the Game\");\n        } else {\n            rewards[msg.sender] = rewards[msg.sender] + price;\n            emit Log(_challenger, msg.sender, \"Challenger lost the Game\");\n        }\n        games[msg.sender][index].status = gameStatus;\n    }\n\n    function claimReward() public {\n        require(rewards[msg.sender] > 0, \"no rewards\");\n        uint256 reward = rewards[msg.sender];\n        rewards[msg.sender] = 0;\n        IERC20(token).transferFrom(address(this), msg.sender, reward);\n        emit RewardLog(msg.sender, rewards[msg.sender], \"Reward claimed\");\n    }\n\n    function isChallengedMethod(address _challenger, address _opponent)\n        internal\n        view\n        returns (bool, uint256)\n    {\n        bool isChallenged = false;\n        uint256 index = 0;\n        for (uint256 i = 0; i < games[_challenger].length; i++) {\n            if (games[_challenger][i].opponent == _opponent) {\n                isChallenged = true;\n                index = i;\n                return (isChallenged, index);\n            }\n        }\n        return (isChallenged, index);\n    }\n\n    function logic(uint8 _challenger, uint8 _opponent)\n        internal\n        pure\n        returns (Status)\n    {\n        Status gameStatus;\n        if (_challenger == _opponent) {\n            gameStatus = Status.Tie;\n            return gameStatus;\n        } else if (\n            (_challenger == 0 && _opponent == 2) ||\n            (_challenger == 1 && _opponent == 0) ||\n            (_challenger == 2 && _opponent == 1)\n        ) {\n            gameStatus = Status.Challenger;\n            return gameStatus;\n        } else {\n            gameStatus = Status.Opponent;\n            return gameStatus;\n        }\n    }\n    // submit their unique move\n    // contract decieds who won\n\n    // Stretch Goals\n    // Include any tests using Hardhat\n    // anyone 2 player can play against each other\n    // reduce gas cost\n    // Let players bet their previous winnings.\n    // How can you entice players to play, knowing that they may have their funds stuck in the contract if they face an uncooperative player?\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}